<!DOCTYPE html>
<meta charset = "utf-8">
<html>
<head>
  <title>Clustered Network</title>


  <script src = "https://d3js.org/d3.v3.min.js"></script>
  <!--<script src = "d3.js"></script>-->


  <style type = "text/css">
  svg {
    border: 1px solid #ccc;
  }
  body {
    font: 10px sans-serif;
  }

  .expandable circle{
    fill: lightsteelblue;
    stroke: black;
    stroke-width: 6px; 
  }

  .expanded circle{
    stroke-width:0px ;
    opacity:.1;
  }

  .expanded text{
    stroke-width:0px;
    opacity:.1 !important;
  }
  

  .node text {
    fill:white;
    stroke:black;
    stroke-width: 1px;
    font-size:18px;
    text-anchor:middle; 
  }

  polygon.focus{
    stroke:black;
    opacity:1; 
  }

  polygon.background{
    stroke:grey;
    opacity:.2; 
  }
  

  path.hull {
    fill: lightsteelblue;
    fill-opacity: 0.3;
  }




  </style>
</head>
<body> 
  <script type = "text/javascript">
var width = 2*960,     // svg width
    height = 2*600,     // svg height 
    marge = 100,    //keep points away from the edges
    bound = true,     //keep points in the box
    dr = 34,      // default point radius
    off = 10,    // cluster hull offset 
    nodesMap = [  ] ,  //"name" -> number
    focus = "child", 
    data, net, force, hullg, hull, linkg, link, linkp, linkInfo, nodeInfo, nodeInfog,  nodeg, node, 

    curve = d3.svg.line()
    .interpolate("cardinal-closed")
    .tension(.85),

    fill = d3.scale.category20(); 
// --------------------------------------------------------

var body = d3.select("body");


//zoom ability
var zoom = d3.behavior.zoom()
.scaleExtent( [ 1, 10 ] )
.on("zoom", zoomed);

//drag ability
var drag = d3.behavior.drag()
.origin(d => d)
.on("dragstart", dragstarted)
.on("drag", dragged)
.on("dragend", dragended);

var canv = body.append("svg").attr("id","canv")
.attr("width", width)
.attr("height", height).call(zoom);

focusvis = canv.append("svg").attr("transform","translate(1,1)").attr("id","focusvis");

vis = focusvis.append("svg").attr("id","vis");

//info text when cursor is over convex hull
crsrText = vis.append("text").attr("id","crsrtxt");


d3.json("conflicts-file.json", function(json) {
  data = json;  
  console.log(data)
  for (var i = 0; i<data.nodes.length; ++i) {
    nodei = data.nodes [ i ] ;
    nodesMap [ nodei.name ] = i;
    nodei.children = [  ] ;
    nodei.expanded=false;
    nodei.x = width*Math.random();
    nodei.y = height*Math.random(); 
    nodei.prevShow=false;


    if (nodei.parent == "root") {nodei.show = true;}
    else {nodei.show = false;}   
  } 

  console.log(nodesMap)


  for (var i = 1; i<data.nodes.length; ++i) {
    nodei = data.nodes [ i ] ;
    parent = data.nodes [ nodesMap [ nodei.parent ] ]
    parent.children.push(nodei);

    //on a la possibilite d'indiquer les liens dans le node, du coup il faut les ajouter a data.links
    suppLinks=nodei.links || [];
    for (k in suppLinks) {
      suppLinks[k] .sourceName=nodei.name;
      data.links.push(suppLinks[k]);
    }


    //on ajoute les liens de parenté
    data.links.push({sourceName:nodei.name, source:nodei ,target:parent, targetName:nodei.parent,params:{type:"belongsTo"}});
  } 

  for (var i = 0; i<data.links.length; ++i) {
    linki = data.links [ i ] ;
    sourceId = nodesMap [ linki.sourceName ] ;
    targetId = nodesMap [ linki.targetName ] ; 

    linki.source = data.nodes [ sourceId ] ;
    linki.target = data.nodes [ targetId ] ;
  }



  //on met les elements svg sur la page html
  hullg = vis.append("g").attr("id","hullg");
  linkg = vis.append("g").attr("id","linkg");
  nodeg = vis.append("g").attr("id","nodeg");
  linkInfog = vis.append("g").attr("id","linkInfog");
  nodeInfog = vis.append("g").attr("id","nodeInfog"); 
  
  //on lance la simulation
  init();

  //effet apparition progressive
  vis.attr("opacity", 1e-6)
  .transition()
  .duration(2000)
  .attr("opacity", 1);
});


function init() { 
  if (force) force.stop();//useful?
  console.log("------init - focus",focus)
  console.log("data",data) 
  
  net = network(data,nodesMap);
  console.log("net",net) 

  force = d3.layout.force()
  .nodes(net.nodes)
  .links(net.links)
  .size( [ width/2, height/2 ] )
  .linkDistance(function(l, i) { return 600; })
  .linkStrength(function(l, i) { return 0.01; })
  .gravity(0.07)    
  .charge(function(n,i) {  return (n.name == focus?-800:-200);})
  .chargeDistance(300)
  .friction(0.9) 
  .start();


  //A noter: force transforme links: il remplace link.source.name par l'objet source, etc... 
  console.log("data",data)

  //convex hull cursor text------------
  vis.on("mouseover",function(){
    x = d3.mouse(this) [ 0 ] ;
    y = d3.mouse(this) [ 1 ] ;
    crsrText.attr("x",x)
    .attr("y",y)
    .attr("display","");
  })

  vis.on("mousemove",function(){
    x = d3.mouse(this) [ 0 ] ;
    y = d3.mouse(this) [ 1 ] ;
    crsrText.attr("x",x)
    .attr("y",y)
    .attr("display","");
  })

  vis.on("mouseout",function(){  
    crsrText.attr("display","none");
  })

  //hulls display----------------------- 
  hullg.selectAll("path.hull").remove();
  hull = hullg.selectAll("path.hull")
  .data(convexHulls(net.nodes, nodesMap, off))
  .enter().append("path")
  .attr("class", "hull")
  .attr("d", drawCluster)
  .style("fill", d => fill(nodesMap [ d.parent ] ) )
  .on("mouseover",d =>   crsrText.text(d.parent))
  .on("click", function(d) {
    if (d.parent!= "root") {
      console.log("hull click", d, arguments, this);

      parentNode = nodes [ nodesMap [ d.parent ] ] ;
      parentNode.expanded = false;
      focus = d.parent;  
      collapseNode(d.parent);
      init(); 
    } 
  });  



  //nodes display------------------- 
  if (node) {node.remove();};//on peut aussi n'enlever que certains noeuds
  node = nodeg.selectAll(".node").data(net.nodes);//, nodeid);

  //node.exit().remove();
  node.enter()
  .append("g") 
  .attr("class",  d => "node"+(d.children.length>0 ? " expandable"+(d.expanded? " expanded":"") : ""))
  .attr("transform",d => "translate("+d.x+","+d.y+")")

  node.append("circle")   
  .attr("r", d => d.size ? d.size + dr : dr+1) 
  .attr("cx",0) 
  .attr("cy",0) 
  .style("fill", d => fill(nodesMap [ d.parent ] ))
  .on("click", function(d) { 
    focus = d.name; 
    console.log(focus)
    if (d.children.length>0){
      console.log("node click", d, arguments, this);
      
      if (d.expanded){
        console.log("yo")
        d.expanded=false;
        collapseNode(d.name)
      }
      else{
        d.expanded=true;
      for (k = 0; k<d.children.length; k++) { 
        d.children[k].prevShow=d.children[k].show;
        d.children [ k ] .show = true;};        //should try to put the name in last to put the sgv element on top
      }
      
    }init();})
  .on("mouseover", (d,i) => toggleInfo(i,"node","block"))
  .on("mouseout",(d,i) =>  toggleInfo(i,"node","none"));

  nodet = node.append("text") 
  .attr("x",0)
  .attr("y",0)
  .text( d => d.name) 

  //node info--------------


  if (nodeInfo) {nodeInfo.remove();};
  nodeInfo = nodeInfog.selectAll("nodeframeg").data(net.nodes)

  nodeInfo.enter().append("g")
  .attr("class","nodeframeg")
  .attr("id", (d,i) => "nodeframeg"+i )
  .attr("display","none")
  .attr("transform", d => "translate(" + d.x + "," + d.y + ")");
 
  infoDisp(nodeInfo,"node")

  //links display------------
  if (link) {link.remove();};//on pourrait aussi n'enlever que certains liens
  link = linkg.selectAll("link").data(net.links);

  console.log("link",link);

  link.enter().append("g")
  .attr("class","link")
  .attr("transform", d => "translate(" + d.source.x + "," + d.source.y + ")")
  .on("mouseover", (d,i) =>   toggleInfo(i,"link",(d.params.type=="belongsTo")? "none" : "block"))
  .on("mouseout", (d,i)  => toggleInfo(i,"link","none"));

  linkp = link.append("polygon")
  .attr("class",d => ((d.source.name == focus)||(d.target.name == focus))? "focus":"background")
  .attr("points",function(d) {
    var dx = d.target.x-d.source.x;
    var dy = d.target.y-d.source.y;
    return "0 0 "+dx+" "+dy}) 
  .style("stroke-width", d => d.params.type=="belongsTo"?   1 : 10)  



  //infotext display (or not)---------------------

  if (linkInfo) {linkInfo.remove();
  };
  linkInfo = linkInfog.selectAll("linkframeg").data(net.links)

  linkInfo.enter().append("g")
  .attr("class","linkframeg")
  .attr("id",function(d,i){return "linkframeg"+i})
  .attr("display","none")
  .attr("transform", function(d) { return "translate(" + (d.source.x+d.target.x)/2 + "," + (d.source.y+d.target.y)/2 + ")"; });

  
  infoDisp(linkInfo,"link")
  






  /*linkInfo.selectAll('rect')
  .attr("width", function(d) {
    console.log(this.parentNode)
    if (d3.select(this.parentNode).attr("display")!="none") {
      console.log("ok")
      return this.parentNode.getBBox().width;}
      else{ return 10;//
    }})
    .attr("height", function(d) {return 10})//this.parentNode.getBBox().height;})
//a=getBBox().height;*/






 //if (truc==4){a=bb}

//Force updates------------------------------

node.call(force.drag);

force.on("tick", function() { 
  if (!hull.empty()) {
    hull.data(convexHulls(net.nodes, nodesMap, off))
    .attr("d", drawCluster);
  }


  node.attr("transform", d => "translate(" + boxBoundx(d.x) + "," + boxBoundy(d.y) + ")" ); 


  link
  .attr("transform", d => "translate(" + boxBoundx(d.source.x )+ "," + boxBoundy(d.source.y) + ")" ) 

  linkp.attr("points",function(d) {
    var dx = boxBoundx(d.target.x)-boxBoundx(d.source.x);
    var dy = boxBoundy(d.target.y)-boxBoundy(d.source.y);
    return "0 0 "+dx+" "+dy}) 

  linkInfo
  .attr("transform",  d => "translate(" + (d.source.x+d.target.x)/2 + "," + (d.source.y+d.target.y)/2 + ")" )

  nodeInfo
  .attr("transform", d => "translate(" + d.x + "," + d.y + ")" )



});

}

function toggleInfo(i,classe,disp){  

  crsrText.text("") ; 



  var element = document.getElementById(classe+"frameg"+i); 

  element.setAttribute("display", disp)

  if (disp!="none") {
    var rect = document.getElementById(classe+"frame"+i);
    //dims du texte dans le "g" parent 
    textHeight=rect.parentNode.childNodes[1].getBBox().height;
    textWidth=rect.parentNode.childNodes[1].getBBox().width;
    
    rect.setAttribute("height",textHeight+40)
    rect.setAttribute("width",textWidth+40)

  } 
    //console.log(element.selectAll("rect").setAttribute("height",20))
  }


  function boxBoundx(x){ 
   if (bound) {
    return Math.min(width-marge,Math.max(marge,x));}
    else {return x}
  }

function boxBoundy(y){ 
  if (bound) {
    return Math.min(height-marge,Math.max(marge,y));}
    else {return y}
  }

/*function linkid(l) {
  var u = nodeid(l.source),
  v = nodeid(l.target);
  return u<v ? u+"|"+v : v+"|"+u;
}*/



function network(data,nodesMap){ //il faudrait prevoir qqch pour que les noeuds qui viennent d'éclore soient répartis près du centre, sinon ils sont mis par défaut en haut à gauche et ça explose

nodes = data.nodes;
console.log("network data",data);
var displayedNodes = [  ] , link, node,
displayedNodesMap = [  ] ,
      //linksSynth = [  ] ,   
      i = 0; 
  //build nodes maps (except root)
  for (var k = 1; k<nodes.length; ++k){
    node = nodes [ k ] ;

    if (node.show) {
      displayedNodes.push(node);
      displayedNodesMap [ k ] = i;
      i++;
    }  
  } 

  console.log(nodes)
  nodes[0].visibleParent=0;

  for (var k = 1; k<nodes.length; ++k){ 
    var looking = true;
    var current = k; 
    nodek=nodes[k];  
    while (looking ){ 
      crtNode = nodes [ current ] ; 
      parentIndex = nodesMap [ crtNode.parent ] ;  
      if (crtNode.show == false ) {//si le noeud est caché
      //on l'ajoute au noeud de son parent direct 
      current = parentIndex; } 
      else {
        if (nodek.show!=nodek.prevShow) {
        //just popped 
        nodek.prevShow=true;  
        nodek.x = nodes [ parentIndex ] .x+50*Math.random();
        nodek.y = nodes [ parentIndex ] .y+50*Math.random();
        //to put speed at 0: (px=previous x)
        nodek.px=nodek.x;
        nodek.py=nodek.y  };


        looking = false;
        nodek .visibleParent = displayedNodesMap [ current ] ;  };





      } 

    } 
    //possible amélioration en mettant à jour les parents rencontrés au cours d'une remontée

    links = data.links 
    linksMap = [  ] ;  
    //on retournera une liste synthétique
    var linksSynth = [  ] ,   j = 0;
    for (var k = 0; k<links.length; ++k){  
      sourceIndex = nodesMap [ links [ k ] .sourceName ] ;
      targetIndex = nodesMap [ links [ k ] .targetName ] ; //on modifie les indices des sources pour qu'elles correspondent aux parents visibles 
      visibleSourceId = nodes [ sourceIndex ] .visibleParent;
      visibleTargetId = nodes [ targetIndex ] .visibleParent;

      if (visibleSourceId!= visibleTargetId){

        linkid = visibleSourceId+"|"+visibleTargetId;
        

        //link.source = visibleSourceId;
        //link.target = visibleTargetId;  //on ajoute a la liste entre ces 2 parents visibles 

        if (linksMap [ linkid ] ){  
          i = linksMap [ linkid ] ;
          linksSynth [ i ] .liste.push(links[k]);
          linksSynth[i].params={type:"multiple links"}
          console.log("multiple")
        }
        else {  

          linksMap [ linkid ] = j;  
          linksSynth [ j ] = {source:visibleSourceId,target:visibleTargetId,liste: [links[k]  ]};
          linksSynth [j].params=links[k].params;
          j = j+1; };  };
        }     

          //build link info here

          console.log("dispnodes",displayedNodes)
          console.log("linkssynth",linksSynth)
          return {links: linksSynth, nodes: displayedNodes}

        }



// constructs the network to visualize


function convexHulls(nodes, nodesMap, offset) {
  var hulls = {};
  var parents = [  ] ;

  // create point sets
  for (var k = 0; k<nodes.length; ++k) {
    var n = nodes [ k ] ;


    var i = nodesMap [ n.parent ] //n.parent,
    l = hulls [ i ] || (hulls [ i ] = [  ] );
    l.push( [ n.x-offset, n.y-offset ] );
    l.push( [ n.x-offset, n.y+offset ] );
    l.push( [ n.x+offset, n.y-offset ] );
    l.push( [ n.x+offset, n.y+offset ] );
    l.parent = n.parent;

  } 

  // create convex hulls
  var hullset = [  ] ;
  for (i in hulls) { 
    hullset.push({parent: hulls [ i ] .parent, path: d3.geom.hull(hulls [ i ] )});
  }

  //if (data.nodes [ 23 ] .show) {a = bbb;}//23 4

  return hullset;
}

function drawCluster(d) {return curve(d.path); // 0.8
}

function nodeid(n) {
  return n.size ? "_g_"+n.group : n.name;
}



function zoomed() {
  vis.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}


function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
}

function dragged(d) {
  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
}

function dragended(d) {
  d3.select(this).classed("dragging", false);
}




function infoDisp(selection,classe) {

  selection.append("rect")
  .attr("id", (d,i) => classe+"frame"+i) 
  .attr("x",-20)
  .attr("y",-20)
  .attr("width",10)
  .attr("height",20)
  .attr("fill","lightgrey")
  .attr("stroke","blue")
  .on("mouseover", (d,i) =>   toggleInfo(i,classe,"block") ) 
  .on("mouseout",(d,i) =>  toggleInfo(i,classe,"none"));


  //selection must have data object of the form "params":{"key1":"value1","key2":"value2", ...}, or no "params" at all
  //var attr="bla";
  var attr="init";

  selection.append("text")
  .style("margin","20px")
  .on("mouseover", (d,i) => toggleInfo(i,classe,"block"))
  .on("mouseout",(d,i) =>  toggleInfo(i,classe,"none"))
  .selectAll("tspan")
  .data(function(d){  
    obj=d.params||{}
    add= (classe=="link")? [["de",d.liste[0].sourceName],["vers",d.liste[0].targetName]] : [["nom",d.name]];
    return add.concat(Object.entries(obj));})
  .enter() 
  .append("tspan")
  .attr("stroke","red")
  .text(d => d[0]+" : ") 
  .each(function(d){
      texte=d3.select(this);
      if (d[1].url){
          texte.append("a")
          .attr("href",d[1].url)
          .attr("target","_blank")
          .text( "("+(d[1].source||"source")+") ")
          .attr("stroke","blue")}
  } )
  .attr("x", 0)
  .attr("dy",20)
  .selectAll("tspan")
  .data(function(d) {
    words=(d[1].url)? d[1].texte.split(" ") : d[1].split(" ");
    return words;})
  .enter()
  .append("tspan").attr("stroke","black")
  .attr("x",function(d,i) {
    if (Number.isInteger((i+1)/8)) {return 0}
  })
  .attr("dy", function(d,i){
    if (Number.isInteger((i+1)/8)) {return 20}
  })
  .text(d => d+" ");
}



function collapseNode(nodeName){
//on peut simplifier avec des auto-appels récursifs
 
  remaining = [ nodeName ] ; 

  while (remaining.length>0){  
    childrenToClose =nodes[ nodesMap [ remaining [ 0 ] ] ].children;
    for (i in childrenToClose){
      childrenToClose [ i ] .show = false;
      childrenToClose [ i ] .expanded = false;
      remaining.push(childrenToClose [ i ] .name);
    };
    remaining.shift();
  }; 
}
</script>
</body>
</html>
